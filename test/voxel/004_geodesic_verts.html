<!DOCTYPE html><html><head><title></title></head><body><script type="module">
    
import Starter, { THREE }  from "../lib/starter.js";
import PointsMesh          from "../lib/PointsMesh.js";
import LinesMesh           from "../lib/LinesMesh.js";

import Maths               from "../../dist/Maths.js";
import Vec3                from "../../dist/Vec3.js";
import Vec4                from "../../dist/Vec4.js";
import Quat                from "../../dist/Quat.js";
import Intersect           from "../../dist/geometry/Intersect.js";
import Colour              from "../../dist/Colour.js";
import Cycle               from '../../dist/animation/Cycle.js';

import Gltf                from "../../dist/misc/Gltf2.js";

import VoxelChunk          from "../../dist/voxel/VoxelChunk.js";
import VoxelizerVol        from "../../dist/voxel/VoxelizerVol.js";
import VoxelMesh           from "../../dist/voxel/VoxelMesh.js";

import Ray                 from "../../dist/ray/Ray.js";
import VoxelRay            from "../../dist/voxel/VoxelRay.js";

let App, pnt, ln
let gChunk, gVox, gSkel, gMesh, gGeodesic;

window.addEventListener( "load", async _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 90, 10, 2.0, [0,0.2,0] ).render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pnt = new PointsMesh( 2500 );
    App.add( pnt.mesh );

    ln = new LinesMesh( 16000 );
    App.add( ln.mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    createSkeleton();
    const prim = await loadModel();
    //createMesh( prim );

    //----------------------------------
    gChunk = new VoxelChunk( 0.05 );
    gChunk.fitBound( prim.position.boundMin, prim.position.boundMax );

    ln.box( gChunk.minBound, gChunk.maxBound, 0x00ffff );
    //ln.box( prim.position.boundMin, prim.position.boundMax, 0x00ff00 );

    //----------------------------------
    gVox   = new VoxelizerVol();
    gVox.fromGeometry( gChunk, prim.position.data, prim.indices.data ); // Fill Voxel Cells based on Mesh Data

    gGeodesic = new VoxelGeodesic()
    gGeodesic.fromChunk( gChunk );
    //showVoxelCells();
    //createVoxelMesh();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //boneRaycast();
    //getBoneVoxIntersects( gChunk );

    crawlBoneVoxels( gChunk, gGeodesic );
    const [ sWeights, sIndices ] = createVertexBones( gChunk, gGeodesic, prim.position.data );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    createMesh( prim, sWeights, sIndices, 1 );

    //createSkinnedMesh( prim, sWeights, sIndices );
    //skinBendTest();
    //skinAnimationTest();
}); 


//#region SETUP
function createSkeleton(){
    let b, bLen = 0.2;
    const bones = [ new THREE.Bone() ];
    bones[ 0 ].position.y = -0.2;

    for( let i=1; i < 6; i++ ){
        b = new THREE.Bone();
        b.position.y = bLen;
        bones[ i-1 ].add( b );
        bones.push( b );
    }

    const skel     = new THREE.Skeleton( bones );
    const boneview = new THREE.SkeletonHelper( bones[0] );
    App.add( bones[0] );
    App.add( boneview );

    gSkel = skel
}

async function loadModel(){
    let gltf = await Gltf.fetch( '../_meshes/war_sword/war_sword.gltf' );
    let prim = gltf.getMesh().primitives[ 0 ];
    return prim;
}

function createMesh( prim, sWeights, sIndices, bIdx ){
    let ggeo     = new THREE.BufferGeometry();
    ggeo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    ggeo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( sWeights && sIndices ){
        ggeo.setAttribute( 'skinWeight', new THREE.BufferAttribute( sWeights, 4 ) );
        ggeo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( sIndices, 4 ) );
    }

    ggeo.computeBoundingBox();

    //let mesh = new THREE.Mesh( ggeo, new THREE.MeshPhongMaterial( { flatShading:true } ) );
    let mesh = new THREE.Mesh( ggeo, SkinWeightMaterial( bIdx ) );
    //mesh.position.x = 0.5;
    App.add( mesh );

    gMesh = mesh;
}

function createSkinnedMesh( prim, sWeights, sIndices ){
    let ggeo     = new THREE.BufferGeometry();
    ggeo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    ggeo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( sWeights && sIndices ){
        ggeo.setAttribute( 'skinWeight', new THREE.BufferAttribute( sWeights, 4 ) );
        ggeo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( sIndices, 4 ) );
    }

    ggeo.computeBoundingBox();

    let mesh = new THREE.SkinnedMesh( ggeo, new THREE.MeshPhongMaterial( { flatShading:true } ) );

    mesh.add( gSkel.bones[ 0 ] );
    mesh.bind( gSkel );
    //mesh.position.x = 0.5;
    App.add( mesh );

    gMesh = mesh;
}

function showVoxelCells(){
    const v = new Vec3();
    for( const itm of gChunk.iterAllCells() ){
        if( itm.isOn ) ln.box( itm.min, itm.max );

        //if( itm.isOn && itm.coord[0] > -1 && itm.coord[0] < 100 ){ 
        //    v.fromLerp( itm.min, itm.max, 0.5 );
        //    pnt.add( v, 0x00ffff, 1, 1 );
        //}
    }
}

function createVoxelMesh(){
    const geo = { vertices:[], normals:[], indices :[], texcoord:[] };
    VoxelMesh.fromChunkRange( gChunk, geo, [0,0,2], [100,100,100] );
    
    let bgeo     = new THREE.BufferGeometry();
    bgeo.setIndex( new THREE.BufferAttribute( new Uint32Array( geo.indices ), 1 ) );
    bgeo.setAttribute( 'position',   new THREE.BufferAttribute( new Float32Array(geo.vertices), 3 ) );
    bgeo.setAttribute( 'normal',     new THREE.BufferAttribute( new Float32Array(geo.normals), 3 ) );

    let mesh    = new THREE.Mesh( bgeo, new THREE.MeshPhongMaterial( {color:0xff0000, side:THREE.DoubleSide, opacity: 1.0, transparent: true, }) );
    App.add( mesh );
}
//#endregion

//#region TESTS

function skinBendTest(){
    const rot   = -Math.PI * 0.20;
    gSkel.bones[ 0 ].rotation.z = rot;
    gSkel.bones[ 1 ].rotation.z = rot;
    gSkel.bones[ 2 ].rotation.z = rot;
    gSkel.bones[ 3 ].rotation.z = rot;
    gSkel.bones[ 4 ].rotation.z = rot;
}

function skinAnimationTest(){
    const cycle = new Cycle( 2 );
    App.onRender = ()=>{
        const t     = cycle.update( 0.01 ).asSin01();
        const ti    = 1 - t;
        const rad   = Math.PI * 0.20;
        const rot   = -rad * ti + rad * t;

        gSkel.bones[ 0 ].rotation.z = rot;
        gSkel.bones[ 1 ].rotation.z = rot;
        gSkel.bones[ 2 ].rotation.z = rot;
        gSkel.bones[ 3 ].rotation.z = rot;
        gSkel.bones[ 4 ].rotation.z = rot;
    }
}

//#endregion

//#region Algorithm: Distance Computation
/*
input: Character skeleton S and voxelized mesh V
foreach bone bi of S do
    // Initialize voxel distance values
    foreach non-exterior voxel vi of V do
        3 dvi = ∞;
    end
    
    Create empty voxel queue Q;
    
    // Initialize bone voxels and add to queue.
    foreach non-exterior voxel vi of V intersecting with bi do
        dvi = 0;
        Push vi to Q;
    9 end

    // Compute geodesic distances
    while Q not empty do
        Pop vi from Q;
        foreach non-exterior voxel neighbor vj to vi do
            dist = dvi + |pvi − pvj|;
            if dvj > dist then
                dvj = dist;
                Push vj to Q;
            end
        end
    end
end
*/

function getBones(){
    const b    = gSkel.bones;
    const bLen = gSkel.bones.length;
    const rtn  = new Array();
    
    const v    = new THREE.Vector3();
    const vv   = new THREE.Vector3();

    for( let i=0; i < bLen-1; i++ ){
        rtn.push({
            idx      : i,
            bone     : b[i],
            origin   : b[i].getWorldPosition( v ).toArray(),
            end      : b[i+1].getWorldPosition( vv ).toArray(),
        });

        //pnt.add( b[i].getWorldPosition( v ).toArray(), 0xffffff, 0.5 );
    }

    return rtn;
}

function boneRaycast(){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const bones = getBones();
    let b = bones[ 0 ];
    //pnt.add( b.origin, 0x00ff00, 1.5 );
    //pnt.add( b.end, 0xff0000, 1.5 );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const ray   = new Ray().fromEndPoints( b.origin, b.end );
    const vray  = new VoxelRay();
    
    let ary = vray.fullIntersect( ray, gChunk );
    let v = new Vec3();
    for( let hit of ary ){
        gChunk.coordMidPoint( hit.coord, v );
        pnt.add( v, 0x00ff00, 1 );
    }
}

function getBoneVoxIntersects( chunk ){
    const bones = getBones();       // List of Bones with its Start/End Position
    const ray   = new Ray();        // Basic Ray Intersect
    const vray  = new VoxelRay();   // Apply Ray to Voxel Chunk
    const out   = new Array();      // Array of Coords that match the bone index

    

    let i, b, h, hits, coords;
    for( i=0; i < bones.length; i++ ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Use Bone data as Ray End Points for Intersection Testing
        b = bones[ i ];
        ray.fromEndPoints( b.origin, b.end );
        hits = vray.fullIntersect( ray, chunk );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If no hits, set null to state that Bone Index N has no voxels
        if( !hits || hits.length == 0 ) out.push( null );
        else{
            
            // Make sure each voxel coord is an active one before saving
            coords = new Array();
            for( h of hits ){

                // Only Save the Cells that are active
                if( chunk.getState( h.coord ) ){        
                    coords.push( h.coord.slice( 0 ) );
                }

            }

            // Save Valid Coords to Bone Index
            out.push( coords );
        }
    }

    return out;
}

function crawlBoneVoxels( chunk, geodes ){
    // Array of starting voxel coordinates for each bone.
    const boneVoxels = getBoneVoxIntersects( chunk );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Set all the voxel distances to zero for all that intersect the bones.
    let bone, bi, coord;
    for( bi=0; bi < boneVoxels.length; bi++ ){
        bone = boneVoxels[ bi ];
        for( coord of bone ){
            if( !geodes.setDistanceIfLower( coord, bi, 0 ) ){
                console.warn( 'Setting Zero Distance didnt work for ', coord );
            }
        }

        //break; // TODO REMOVE
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Figure out how far each voxel is from each bone.
    for( bi=0; bi < boneVoxels.length; bi++ ){
        boneCrawl( bi, boneVoxels[ bi ], chunk, geodes );
        //break; // TODO REMOVE
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //viewBoneGeoWeight( 0 );
    //computeWeights( 1 );
}

function boneCrawl( boneIdx, initCoords, chunk, geodes ){
    const queue = initCoords.slice( 0 ); // Make a copy of initial coordinates

    //let min = new Vec3();
    //let max = new Vec3();
    //let cell, neigh;
    let cdist, ndist;
    let coord;
    let ncoord, neighbors;
    let cpos;
    let npos;

    while( queue.length > 0 ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        coord       = queue.pop();                          // Starting Voxel Coord
        neighbors   = chunk.getActiveNeighbors( coord );    // Get its 6 Active Neighbors
        cdist       = geodes.getDistance( coord, boneIdx ); // Get current distance from bone starting voxel has
        cpos        = geodes.getCellMidPoint( coord );      // Get the Position of Starting Voxel

        //console.log( "MAIN", coord, cdist );
        //pnt.add( cpos, 0x00ff00, 0.5 );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //chunk.coordBound( coord, min, max );
        //ln.box( min, max, 0x00ff00 );

        // For each neightor, compute its distance away from the bone
        for( ncoord of neighbors ){
            npos    = geodes.getCellMidPoint( ncoord ); // Center Point of Neighbor Voxel
            ndist   = cdist + Vec3.len( cpos, npos );   // Neighbor's Distance from Bone
            //console.log( ncoord, cdist, ndist );

            // If its the shortest distance from bone, Add it to the queue
            if( geodes.setDistanceIfLower( ncoord, boneIdx, ndist ) ){
                queue.push( ncoord );
                //console.log( "queue", ncoord );
                //pnt.add( npos, 0x00ffff, 1 );
            }else{
                //pnt.add( npos, 0xff0000, 1 );
            }

            //chunk.coordBound( ncoord, min, max );
            //ln.box( min, max, 0x00ffff );
            //break;
        }

        //break;
    }
    
    //console.log( geodes );
    //console.log( Vec3.len( chunk.minBound, chunk.maxBound ) );
}

//#endregion


function computeWeights( boneIdx ){
    const maxDist = Vec3.len( gChunk.minBound, gChunk.maxBound );
    const minDist = 0.00001; // Can't use Zero because of Weight equation, so need a min number.
    const smooth  = 0.3;

    let map, wgt;

    let green = new Colour( 'green' );
    let red   = new Colour( 'red' );
    let blue  = new Colour( 'blue' );
    let color = new Colour();

    for( const cell of gGeodesic.cells.values() ){
        
        map = cell.computeWeights( minDist, maxDist, smooth ); 
        //break;
        
        wgt = map.get( boneIdx );
        if( !wgt ) wgt = 0;

        if( wgt > 0.5 ){
            //wgt   = Maths.smoothStep( 0.5, 1.0, wgt );
            wgt   = wgt * 2 + 1;
            color.fromLerp( green, red, wgt );
        }else{
            //wgt   = Maths.smoothStep( 0.0, 0.5, wgt );
            wgt   = wgt * 2;
            color.fromLerp( blue, green, wgt );
        }

        pnt.add( cell.midPoint, color.toRGBNumber() );

        
    }


}

function viewBoneGeoWeight( boneIdx ){
    const maxDist = Vec3.len( gChunk.minBound, gChunk.maxBound );
    const minDist = 0.001; // Can't use Zero because of Weight equation, so need a min number.
    const smooth  = 0.001;

    let cDist;
    let nDist; // Normalized
    let wgt;
    let maxWeight = -Infinity;
    for( const cell of gGeodesic.cells.values() ){
        
        cDist = Math.max( minDist, cell.getDistance( boneIdx ) );
        //cDist = cell.getDistance( boneIdx );
        //if( cDist <= 0 ){ continue; }

        nDist = cDist / maxDist;
        wgt   = ( 1 / ( (1 - smooth)*nDist  + smooth*(nDist**2) ) ) ** 2;

        cell.setWeight( boneIdx, wgt );

        //if( wgt > maxWeight ) maxWeight = wgt;
        //pnt.add( cell.midPoint );
    }

    /*
    let norm, color;
    for( const cell of gGeodesic.cells.values() ){
        norm = cell.getWeight( boneIdx ) / maxWeight;
        if( norm == 0 ) norm = 1;
        norm = Maths.clamp01( norm );

        color = 0xffff00 * (1-norm) + 0xff0000 * norm;

        pnt.add( cell.midPoint, color, );
    }
    */
}

function createVertexBones( chunk, geodes, verts ){    
    const vertCnt   = verts.length / 3;
    const v         = new Vec3();
    const coord     = new Vec3();
    const wgt       = new Vec4();
    const idx       = new Vec4();

    const weights   = new Float32Array( vertCnt * 4 );
    const indices   = new Float32Array( vertCnt * 4 );

    for( let i=0; i < vertCnt; i++ ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        v.fromBuf( verts, i*3 );          // Get Vertex Pos
        chunk.posCoord( v, coord );     // Get its voxel coord.

        wgt.xyzw( 0,0,0,0 );            // Reset Data
        idx.xyzw( 0,0,0,0 );

        // 
        geodes.getVertexWeight( coord, v, wgt, idx );
        wgt.toBuf( weights, i*4 );
        idx.toBuf( indices, i*4 );

        //console.log( v, coord );

        //pnt.add( v, 0x00ff00, 1 );

        //break;
    }

    return [ weights, indices ];
}

//#region Handle Storing Geodesic distance of each volume voxel to bone voxel
// http://www.delasa.net/data/sca2013_voxelization.pdf

class GeodesicItem{
    distance = Infinity;
    //weight   = 0;
    boneIdx  = 0;
    //bweight  = 0;
    constructor( idx ){ this.boneIdx = idx; }

    //calcWeight( minDist, maxDist, smooth=0.7 ){
    //    const cDist = Math.max( minDist, this.distance );
    //    const nDist = cDist / maxDist;
    //    this.weight = ( 1 / ( (1 - smooth)*nDist  + smooth*(nDist**2) ) ) ** 2;
    //}
}

class GeodesicCell{
    midPoint    = [0,0,0];
    items       = new Map();

    constructor( mid ){
        Vec3.copy( mid, this.midPoint );
    }

    add( idx ){
        const gi = new GeodesicItem( idx );
        this.items.set( idx, gi );
        return gi;
    }

    setWeight( bIdx, wgt ){
        this.items.get( bIdx ).weight = wgt;
    }

    getWeight( bIdx ){
        return this.items.get( bIdx ).weight;
    }

    getDistance( bIdx ){
        return this.items.get( bIdx ).distance;
    }

    /*
    computeWeights( minDist, maxDist, smooth=0.7 ){
        //------------------------------------------
        let i;
        for( i of this.items.values() ) i.calcWeight( minDist, maxDist, smooth );

        //------------------------------------------
        const wLmt = 100.0;
        const ary = Array
             .from( this.items.values() )                   // Get All Bones Items
             .filter( (a)=>(a.weight >= wLmt) )
             .sort( (a,b)=>( a.weight > b.weight )? -1:1 )  // Sort desc weight
             .slice( 0, 4 );                                // Top 4 only

        // Total Weight of all Bones
        const sum = ary.reduce( (p,c)=>{ return p + c.weight }, 0 );    
        const wgt = ary.reduce( (p,c)=>{ p.set( c.boneIdx, c.weight/sum ); return p }, new Map() );

        //const wgtx = ary.map( i=>i.weight/sum );                         // Normalize Weight
        //const idx = ary.map( i=>i.boneIdx );                            // 
        //console.log( ary, sum, wgtx );

        return wgt;
    }
    */
}

class VoxelGeodesic{
    cells       = new Map();

    smooth      = 0.7;
    minDistance = 0.0001;   // Can't use Zero because of Weight equation, so need a min number.
    maxDistance = 0;

    constructor(){}

    addCell( coord, midPoint ){
        const k = Vec3.toKey( coord );
        const c = new GeodesicCell( midPoint );
        
        this.cells.set( k, c );
        //console.log( k );
        //pnt.add( midPoint, 0xff0000 );
        return this;
    }

    getCell( coord ){
        const k = Vec3.toKey( coord );
        return this.cells.get( k );
    }

    setDistanceIfLower( coord, bIdx, dist ){
        const c = this.getCell( coord );
        let   i = c.items.get( bIdx );
        
        if( !i ) i = c.add( bIdx );

        if( dist < i.distance ){
            i.distance = dist;
            return true;
        }

        return false;
    }

    getDistance( coord, bIdx ){
        const c = this.getCell( coord );
        const i = c.items.get( bIdx );
        return ( i )? i.distance : Infinity;
    }

    getCellMidPoint( coord ){
        const k = Vec3.toKey( coord );
        return this.cells.get( k ).midPoint;
    }

    getVertexWeight( coord, vert, outWeights, outIndices ){
        // D   = Product of BBox Extends, using VecLen( minPos, maxPos )
        // distNormalized : dn = ( boneDistance + ( vertex - cellMidPoint ) ) / D;
        // weight = ( 1 / (1-smooth)*dn + smooth*dn^2 )^2
        
        // 1. Get Vert delta distance from voxel center.
        // 2. Get the Top 4 Bones
        // 3. Compute Vertex Normalized Distance for each bone
        // 4. Compute The Vertex Weight.
        // 5. Compute Weight Sum
        // 6. Normalize Weight with sum
        // 7. Filter out bones with very little influence

        const cell = this.getCell( coord );
        const vlen = Vec3.len( cell.midPoint, vert );
        //console.log( cell, vlen );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Collect the bone data thats needed.
        const bones = Array
            .from( cell.items.values() )
            .sort( (a,b)=>(a.distance < b.distance )?-1:1 ) // Shortest to Furthest distance
            .slice( 0, 4 )                                  // Cap at 4 bones because of Vec4 Limit
        ;

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Add Vertex to Centroid Distance to Voxel Distance, then divide it by max possible distance for the chunk.
        const ndist = bones.map( i=>{ return Math.max( this.minDistance, i.distance + vlen ) / this.maxDistance } );

        // For each Normalized Distance, Compute its overall weight with a smoothing factor
        const wgt   = ndist.map( dist=>{ return ( 1 / ( (1 - this.smooth)*dist + this.smooth*(dist**2) ) ) ** 2; } );

        // Total Weight of all Bones
        let sum     = wgt.reduce( (p,c)=>p+c, 0 );
        
        // Normalize Weight
        wgt.forEach( (v,i,a)=>a[i] /= sum );
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Extra Filtering to limit bone influence
        
        // Remove bone influence if less then 0.1
        const MIN_NWGT  = 0.1;
        const minW      = wgt.reduce( (p,c)=>Math.min(p,c), Infinity );
        if( minW < MIN_NWGT ){
            wgt.forEach( (v,i,a)=>{ if( v < 0.1 ) a[i]=0; } );  // Set Zero on Specific Bones
            
            sum = wgt.reduce( (p,c)=>p+c, 0 );                  // Compute new Sum
            
            wgt.forEach( (v,i,a)=>a[i] /= sum );                // Normalize Again
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Save Results
        wgt.forEach( (v,i)=>{
            if( v != 0 ){
                outWeights[ i ] = v;
                outIndices[ i ] = bones[ i ].boneIdx;
            }
        });

        /*
        console.log( 'bones', bones );
        console.log( 'ndist', ndist );
        console.log( 'wgt', wgt );
        console.log( 'sum', sum );
        console.log( 'minW', minW );

        console.log( 'owgt', outWeights );
        console.log( 'oidx', outIndices );
        */
    }

    // Create GeoDesic Cell data for each active voxel cell
    fromChunk( chunk ){
        this.maxDistance = Vec3.len( chunk.minBound, chunk.maxBound );

        const v = new Vec3();
        let   c = null;

        for( const itm of gChunk.iterAllCells() ){
            if( !itm.isOn ) continue;     
            
            v.fromLerp( itm.min, itm.max, 0.5 );    // cell mid point
            this.addCell( itm.coord, v );           // add active cell to collection
            
            //ln.box( itm.min, itm.max );
            //console.log( itm.coord );
        }
    }
}
//#endregion


function SkinWeightMaterial( bIdx=4 ){
    let mat = new THREE.RawShaderMaterial({
        //side        : (isDoubleSide)? THREE.DoubleSide : THREE.FrontSide,
		uniforms		:  {
            boneIdx   : { type :'float', value:bIdx },
        },
        
        vertexShader	: `#version 300 es
        in	vec3	position;
        in  vec4    skinIndex;
        in  vec4    skinWeight;
        
        out vec3 frag_color;

        uniform     float   boneIdx;
        uniform 	mat4	modelMatrix;
        uniform 	mat4	viewMatrix;
        uniform 	mat4	projectionMatrix;

        const vec3 red   = vec3( 1.0, 0.0, 0.0 );
        const vec3 green = vec3( 0.0, 1.0, 0.0 );
        const vec3 blue  = vec3( 0.0, 0.0, 1.0 );

		void main(){
            int bIdx    = int( boneIdx );
            ivec4 sIdx  = ivec4( skinIndex );
            float wgt   = 0.0;

            if( sIdx.x == bIdx )      wgt = skinWeight.x;
            else if( sIdx.y == bIdx ) wgt = skinWeight.y;
            else if( sIdx.z == bIdx ) wgt = skinWeight.z;
            else if( sIdx.w == bIdx ) wgt = skinWeight.w;

            if( wgt > 0.5 ) frag_color = mix( green, red, wgt * 2.0 + 1.0 );
            else            frag_color = mix( blue, green, wgt * 2.0 );

            vec4 wpos   = modelMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * viewMatrix * wpos; 
        }`,
        
		fragmentShader	: `#version 300 es
        precision mediump float;      
        in  vec3 frag_color;
        out	vec4 out_color;

        void main() {
		    out_color = vec4( frag_color, 1.0 );
		}`,
    });

    return mat;
}


</script></bod4></html>