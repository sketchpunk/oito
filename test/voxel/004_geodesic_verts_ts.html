<!DOCTYPE html><html><head><title></title></head><body><script type="module">
    
import Starter, { THREE }  from "../lib/starter.js";
import PointsMesh          from "../lib/PointsMesh.js";
import LinesMesh           from "../lib/LinesMesh.js";

import Maths               from "../../dist/Maths.js";
import Vec3                from "../../dist/Vec3.js";
import Vec4                from "../../dist/Vec4.js";
import Quat                from "../../dist/Quat.js";
import Intersect           from "../../dist/geometry/Intersect.js";
import Colour              from "../../dist/Colour.js";
import Cycle               from '../../dist/animation/Cycle.js';

import Gltf                from "../../dist/misc/Gltf2.js";

import Armature            from '../../dist/armature/Armature.js';
import BoneViewMesh        from '../armature/lib/BoneViewMesh.js';

import VoxelChunk          from "../../dist/voxel/VoxelChunk.js";
import SolidVoxelizer        from "../../dist/voxel/SolidVoxelizer.js";
import VoxelMesh           from "../../dist/voxel/VoxelMesh.js";

import VoxelGeodesic       from '../../dist/armature/autoskin/VoxelGeodesic.js';

import Ray                 from "../../dist/ray/Ray.js";
import VoxelRay            from "../../dist/voxel/VoxelRay.js";

let App, pnt, ln
let gChunk, gVox, gSkel, gMesh, gGeodesic;

window.addEventListener( "load", async _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 0, 10, 5.0, [0,0.2,0] ).render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pnt = new PointsMesh( 2500 );
    App.add( pnt.mesh );

    ln = new LinesMesh( 70000 );
    App.add( ln.mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    //-------------------------------------
    // Get Mesh Data
    //const gltf = await Gltf.fetch( '../_meshes/war_sword/war_sword.gltf' );
    const gltf = await Gltf.fetch( '../_meshes/vegeta/vegeta.gltf' );
    const geo  = gltf.getMesh().primitives[ 0 ];

    toMesh( geo );

    //const skin = gltf.getSkin();

    /*
    for( let j of skin.joints ){
        let o = {
            name: j.name.replace( 'mixamorig:', '' ), idx: j.index, pidx: j.parentIndex, pos:j.position, rot:j.rotation
        };
        console.log( JSON.stringify( o ) );
    }
    */
    
    //return;

    //-------------------------------------
    // Procedurally create a simple skeleton using Armature
    const arm  = new Armature();
    //for( let i=0; i < 5; i++ ) arm.addBone( 'bone'+i, (i!=0)? i-1:null, null, (i==0)?[0,-0.2,0]:[0,0.2,0], null );
    
    const aryBones = [
        {"name":"Hips","idx":0,"pidx":null,"pos":[0.001691931509412825,0.8518908023834229,0.04233919829130173],"rot":null},
        {"name":"Spine","idx":1,"pidx":0,"pos":[0,0.07300597429275513,-0.013434894382953644],"rot":[-0.0908687561750412,0,0,0.9958629608154297]},
        {"name":"Spine1","idx":2,"pidx":1,"pos":[-2.3283064365386963e-10,0.08660377562046051,-1.6763806343078613e-8],"rot":[8.940696716308594e-8,0,0,1]},
        {"name":"Spine2","idx":3,"pidx":2,"pos":[-1.1641532182693481e-10,0.09897592663764954,7.450580596923828e-9],"rot":[-1.7136335372924805e-7,0,0,1]},
        {"name":"Neck","idx":4,"pidx":3,"pos":[1.1641532182693481e-10,0.11134748160839081,2.60770320892334e-8],"rot":[0.09086886793375015,0,0,0.9958629608154297]},
        {"name":"Head","idx":5,"pidx":4,"pos":[1.1641532182693481e-10,0.08891844749450684,-0.015046834945678711],"rot":[-8.73254357713904e-9,0,0,1]},
        {"name":"LeftShoulder","idx":6,"pidx":3,"pos":[0.06169901043176651,0.09800639748573303,-0.0023431330919265747],"rot":[0.5396683216094971,0.4524856507778168,-0.5605334043502808,0.4356802701950073]},
        {"name":"LeftArm","idx":7,"pidx":6,"pos":[-2.561137080192566e-8,0.12533706426620483,-1.0710209608078003e-8],"rot":[-0.057084135711193085,-0.001414879341609776,0.024739207699894905,0.9980618953704834]},
        {"name":"LeftForeArm","idx":8,"pidx":7,"pos":[4.260800778865814e-8,0.174209862947464,7.869675755500793e-8],"rot":[-0.07619540393352509,0.00150683440733701,-0.019718056544661522,0.9968968033790588]},
        {"name":"LeftHand","idx":9,"pidx":8,"pos":[-5.029141902923584e-8,0.22670170664787292,1.2014061212539673e-7],"rot":[-0.10912764817476273,0.0898929312825203,0.00004303800596971996,0.9899548292160034]},
        {"name":"RightShoulder","idx":10,"pidx":3,"pos":[-0.06169900670647621,0.09804624319076538,-0.002559661865234375],"rot":[0.5385406017303467,-0.45344027876853943,0.5613337755203247,0.4350522458553314]},
        {"name":"RightArm","idx":11,"pidx":10,"pos":[5.122274160385132e-9,0.12533719837665558,-8.195638656616211e-8],"rot":[-0.05638902261853218,0.0015993844717741013,-0.02830304577946663,0.9980063438415527]},
        {"name":"RightForeArm","idx":12,"pidx":11,"pos":[3.259629011154175e-9,0.17422938346862793,1.126900315284729e-7],"rot":[-0.07646241784095764,-0.001603146200068295,0.020896486937999725,0.9968522191047668]},
        {"name":"RightHand","idx":13,"pidx":12,"pos":[1.862645149230957e-9,0.22669261693954468,8.707866072654724e-8],"rot":[-0.1098177433013916,-0.08273951709270477,0.0006666815024800599,0.990501880645752]},
        {"name":"LeftUpLeg","idx":14,"pidx":0,"pos":[0.07827957719564438,-0.04049783945083618,-0.01180013082921505],"rot":[0.0012189809931442142,0.03373518958687782,-0.9987580180168152,0.03664567321538925]},
        {"name":"LeftLeg","idx":15,"pidx":14,"pos":[2.5429471861571074e-9,0.37693268060684204,9.108589438255876e-10],"rot":[-0.013338188640773296,-0.000002298355411767261,0.000789112295024097,0.9999107718467712]},
        {"name":"LeftFoot","idx":16,"pidx":15,"pos":[1.8335413187742233e-9,0.35818231105804443,3.346940502524376e-9],"rot":[0.5369540452957153,-0.06625143438577652,0.04235189035534859,0.8399389386177063]},
        {"name":"RightUpLeg","idx":17,"pidx":0,"pos":[-0.07827957719564438,-0.04049783945083618,-0.011591173708438873],"rot":[0.0012514338595792651,-0.03403257951140404,0.9987480044364929,0.03664257749915123]},
        {"name":"RightLeg","idx":18,"pidx":17,"pos":[-9.489667718298733e-9,0.3769416809082031,-3.2159732654690742e-9],"rot":[-0.016968226060271263,0.00001146549857367063,-0.0007698459085077047,0.9998557567596436]},
        {"name":"RightFoot","idx":19,"pidx":18,"pos":[-2.7066562324762344e-9,0.3584497272968292,3.754394128918648e-9],"rot":[0.5454418659210205,0.06389955431222916,-0.04175892844796181,0.8346652984619141]},
    ];

    for( const b of aryBones ) arm.addBone( b.name, b.pidx, b.rot, b.pos );
    arm.bind( null, 0.2 );

    //const boneView = new BoneViewMesh( arm ).updateFromPose( arm );
    //App.add( boneView );

    //-------------------------------------
    // Auto Skin the Mesh in Steps
    const autoskin = new VGAutoSkinning( 0.03 )
        .setBones( arm.bones )
        .setSmooth( 0.7 )
        .setBounds( geo.position.boundMin, geo.position.boundMax )
        .setMesh( geo.indices.data, geo.position.data );

    //ln.box( autoskin.chunk.minBound, autoskin.chunk.maxBound, 0x00ffff ); // See Voxel Chunk Area

    console.time( 'Begin Autoskinning' );
    autoskin.step1_voxelizeMesh();
    for( const itm of autoskin.chunk.iterAllCells() ) if( itm.isOn ) ln.box( itm.min, itm.max );
    return;
    autoskin.step2_boneVoxelIntersection();
    //console.log( autoskin.boneVoxels );

    autoskin.step3_voxelCrawler();

    const [ bWeights, bIndices ] = autoskin.step4_computeBoneWeights();
    //console.log( bWeights, bIndices );
    console.timeEnd( 'Begin Autoskinning' );
    //-------------------------------------
    //createWeightViewMesh( geo, bWeights, bIndices, 1 );

    buildSkeletonMesh( arm, geo, bWeights, bIndices );
    //skinBendTest();
    //skinAnimationTest();
    skinBodyTest();
}); 


//#region TESTING

function createWeightViewMesh( prim, sWeights, sIndices, bIdx ){
    let ggeo     = new THREE.BufferGeometry();
    ggeo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    ggeo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( sWeights && sIndices ){
        ggeo.setAttribute( 'skinWeight', new THREE.BufferAttribute( sWeights, 4 ) );
        ggeo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( sIndices, 4 ) );
    }

    ggeo.computeBoundingBox();

    //let mesh = new THREE.Mesh( ggeo, new THREE.MeshPhongMaterial( { flatShading:true } ) );
    let mesh = new THREE.Mesh( ggeo, SkinWeightMaterial( bIdx ) );
    //mesh.position.x = 0.5;
    App.add( mesh );

    gMesh = mesh;
}

function buildSkeletonMesh( arm, geo, sWeights, sIndices ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Convert Armature to THREE.Skeleton
    const bCnt  = arm.bones.length;
    const bones = new Array( bCnt );
    let   bn;
    for( let b of arm.bones ){
        bn = new THREE.Bone();
        bn.position.fromArray( b.local.pos );
        bn.quaternion.fromArray( b.local.rot );

        bones[ b.idx ] = bn;
        if( b.pidx != null ) bones[ b.pidx ].add( bn );
    }

    const skel = new THREE.Skeleton( bones );
    gSkel = skel;

    
    const boneview = new THREE.SkeletonHelper( bones[0] );
    App.add( boneview );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const bGeo = new THREE.BufferGeometry();
    bGeo.setIndex( new THREE.BufferAttribute( geo.indices.data, 1 ) );
    bGeo.setAttribute( 'position', new THREE.BufferAttribute( geo.position.data, geo.position.componentLen ) );

    if( sWeights && sIndices ){
        bGeo.setAttribute( 'skinWeight', new THREE.BufferAttribute( sWeights, 4 ) );
        bGeo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( sIndices, 4 ) );
    }

    const mat  = new THREE.MeshPhongMaterial( { flatShading:true } );
    const mesh = new THREE.SkinnedMesh( bGeo, mat );
    mesh.add( gSkel.bones[ 0 ] );
    mesh.bind( gSkel );
    App.add( mesh );

    gMesh = mesh;
}

function skinBendTest(){
    const rot   = -Math.PI * 0.05;
    gSkel.bones[ 0 ].rotation.z = rot;
    gSkel.bones[ 1 ].rotation.z = rot;
    gSkel.bones[ 2 ].rotation.z = rot;
    gSkel.bones[ 3 ].rotation.z = rot;
    gSkel.bones[ 4 ].rotation.z = rot;
}


function skinBodyTest(){
    const rot = (v)=>(v * Math.PI / 180);

    gSkel.bones[ 1 ].rotation.x = rot( -20 );
    gSkel.bones[ 2 ].rotation.x = rot( -20 );
    gSkel.bones[ 3 ].rotation.x = rot( -20 );
    gSkel.bones[ 5 ].rotation.x = rot( -50 );

    gSkel.bones[ 11 ].rotation.x = rot( 50 );
    gSkel.bones[ 12 ].rotation.z = rot( -50 );

    gSkel.bones[ 14 ].rotation.x = rot( -90 );
    gSkel.bones[ 15 ].rotation.x = rot( -90 );
    //gSkel.bones[ 16 ].rotation.x = rot( 45 );
}

function skinAnimationTest(){
    const cycle = new Cycle( 2 );
    App.onRender = ()=>{
        const t     = cycle.update( 0.01 ).asSin01();
        const ti    = 1 - t;
        const rad   = Math.PI * 0.20;
        const rot   = -rad * ti + rad * t;

        gSkel.bones[ 0 ].rotation.z = rot;
        gSkel.bones[ 1 ].rotation.z = rot;
        gSkel.bones[ 2 ].rotation.z = rot;
        gSkel.bones[ 3 ].rotation.z = rot;
        gSkel.bones[ 4 ].rotation.z = rot;
    }
}

function toMesh( prim ){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute( 'position', new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    console.log( prim );

    if( prim.indices ) geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    if( prim.normal )  geo.setAttribute( 'normal', new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );

    //if( prim.joints_0 && prim.weights_0 ){
    //    geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
    //    geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data, prim.joints_0.componentLen ) );
    //}

    App.add( new THREE.Mesh( geo, new THREE.MeshPhongMaterial( {color:0xffffff, flatShading:true }) ) );
}

//#endregion


/* Algorithm: Distance Computation
input: Character skeleton S and voxelized mesh V
foreach bone bi of S do
    // Initialize voxel distance values
    foreach non-exterior voxel vi of V do
        3 dvi = ∞;
    end
    
    Create empty voxel queue Q;
    
    // Initialize bone voxels and add to queue.
    foreach non-exterior voxel vi of V intersecting with bi do
        dvi = 0;
        Push vi to Q;
    9 end

    // Compute geodesic distances
    while Q not empty do
        Pop vi from Q;
        foreach non-exterior voxel neighbor vj to vi do
            dist = dvi + |pvi − pvj|;
            if dvj > dist then
                dvj = dist;
                Push vj to Q;
            end
        end
    end
end
*/


class VGAutoSkinning{
    //#region MAIN
    chunk       = new VoxelChunk();     // Voxel Grid Data Structure
    voxelize    = new SolidVoxelizer(); // Mesh Solid Voxelizer
    geodesic    = new VoxelGeodesic();  // Track distance of each active voxel to each bone.
    bones       = null;
    vertices    = null;
    indices     = null;
    boneVoxels  = null;

    constructor( voxCellSize=0.05 ){
        this.chunk.setCellSize( voxCellSize );  // Voxel Size in the chunk.

        
    }
    //#endregion

    //#region SETTERS
    
    setMesh( indices, vertices ){
        this.vertices = vertices;
        this.indices  = indices;
        return this;
    }

    setBones( bAry ){
        this.bones = bAry; 
        return this;
    }

    setBounds( min, max, overScale=1 ){ this.chunk.fitBound( min, max, overScale ); return this; }
    
    setSmooth( v ){ this.geodesic.smooth = 0.9; return this; }

    //#endregion

    //#region STEP 1
    step1_voxelizeMesh(){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // At the first stage, we need to figure all the voxel cells that intersect
        // all the triangles of the mesh. The main idea:
        // 1. Loop Every Triangle
        // 2. Compute the Triangle's Bounding Box
        // 3. Using the BoundingBox, find the Range of voxels the triangle exist in.
        // 4. Test each voxel for BBOX-TRIANGLE Intersection.
        // 5. For Every Voxel that intersects a triangle, it's set as active|on in the chunk object.
        this.voxelize.fromGeometry( this.chunk, this.vertices, this.indices );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Prepare to save Bone Distance data for each active voxel cell
        this.geodesic.fromChunk( this.chunk );

        return this;
    }
    //#endregion

    //#region STEP 2
    step2_boneVoxelIntersection(){
        // 1. Turn Bone Data to a collection of segments
        // 2. Use each segment as a ray to find every active voxel cell that the segment intersects.

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // For every segment, find all the voxels it intersects
        const segments  = this.calcBoneSegments();

        const bCnt      = this.bones.length;
        const ray       = new Ray();        // Basic Ray Intersect
        const vray      = new VoxelRay();   // Apply Ray to Voxel Chunk
        
        this.boneVoxels = [];               // Each bone has a collection of voxel coordinates
    
        let i, h, hits;
        for( i=0; i < bCnt; i++ ){
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ray.fromEndPoints( segments[ i ].origin, segments[ i ].end );
            hits = vray.fullIntersect( ray, this.chunk );

            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // If no hits, set null to state that Bone Index has no voxels
            // Having no voxels is a problem since the bones should all exist
            // within the mesh's bounding box.
            if( !hits || hits.length == 0 ) out.push( null );
            else{
                
                // Make sure each voxel coord is an active one before saving
                const coords = new Array();
                for( h of hits ){
                    if( this.chunk.getState( h.coord ) ) coords.push( h.coord.slice( 0 ) );
                }

                this.boneVoxels.push( coords );
            }
        }
    }

    calcBoneSegments(){
        const bCnt      = this.bones.length;
        const segments  = new Array( bCnt );
        const v         = new Vec3();
        let b;
        for( b of this.bones ){
            //-------------------------------
            // Compute Bone Tail Position
            v.xyz( 0, b.len, 0 );
            b.world.transformVec3( v );

            //-------------------------------
            // Save Data
            segments[ b.idx ] = {
                idx     : b.idx,
                origin  : b.world.pos.toArray(),
                end     : v.toArray(), 
            };
        }

        return segments;
    }
    //#endregion

    //#region STEP 3

    step3_voxelCrawler(){
        // 1. Assign a bone distance of zero for each voxel found.
        // 2. Use each bone's intersected voxel coordinates as the starting point for the Voxel Crawler which
        //    will access all the active voxels and determine how far each one is from said bone. The idea is
        //    like the Dijkstra's Shortest Path Algorithm.

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // For every bone voxel, set its distance to zero as 
        // they are the closests voxel to each bone.
        let bv, bi, coord;
        for( bi=0; bi < this.boneVoxels.length; bi++ ){
            //------------------------------------
            bv = this.boneVoxels[ bi ];
            for( coord of bv ){
                if( !this.geodesic.setDistanceIfLower( coord, bi, 0 ) ) console.warn( 'Setting Zero Distance didnt work for ', coord );
            }

            //------------------------------------
            this.boneNeighborCrawl( bi, this.boneVoxels[ bi ] );
        }
    }

    // For each bone, crawl through out the voxel grid to map out 
    // the distance each voxel is from the bone.
    boneNeighborCrawl( boneIdx, initCoords ){
        const queue     = initCoords.slice( 0 ); // Make a copy of initial coordinates
        const chunk     = this.chunk;
        const geodes    = this.geodesic;

        let cdist, ndist, cpos, npos, neighbors;
        let coord, ncoord;

        while( queue.length > 0 ){
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            coord       = queue.pop();                          // Center voxel coord
            neighbors   = chunk.getActiveNeighbors( coord );    // Get its 6 active neighbors
            cdist       = geodes.getDistance( coord, boneIdx ); // Get current distance of the center voxel
            cpos        = geodes.getCellMidPoint( coord );      // Get the mid position of the center Voxel

            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // For each neightor, compute its distance from the bone
            for( ncoord of neighbors ){
                npos    = geodes.getCellMidPoint( ncoord ); // Center Point of Neighbor Voxel
                ndist   = cdist + Vec3.len( cpos, npos );   // Neighbor's Distance from Bone

                // If its the shortest distance from bone, Add it to the queue
                if( geodes.setDistanceIfLower( ncoord, boneIdx, ndist ) ) queue.push( ncoord );
            }
        }
    }

    //#endregion

    //#region STEP 4
    step4_computeBoneWeights(){
        // 1. Grab each vertex from the mesh
        // 2. Compute which voxel it exists in.
        // 3. In the Geodesic object, filter the 4 closest bones in the voxel.
        // 4. Compute the weight based on the vertex & voxel centroid & voxel distance
        // 5. Normalize the 4 weights.
        // 6. Do some extra filtering like removing bones with very little or near zero influence
        // 7. ReNormalize the Weights after the previous filtering
        // 8. With the remaining Weights, get the bone indices.

        const verts     = this.vertices;
        const vertCnt   = verts.length / 3;
        const v         = new Vec3();
        const coord     = new Vec3();
        const wgt       = new Vec4();
        const idx       = new Vec4();

        const weights   = new Float32Array( vertCnt * 4 );
        const indices   = new Float32Array( vertCnt * 4 );

        for( let i=0; i < vertCnt; i++ ){
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            v.fromBuf( verts, i*3 );            // Get Vertex Pos
            this.chunk.posCoord( v, coord );    // Get its voxel coord.

            wgt.xyzw( 0,0,0,0 );                // Reset Data
            idx.xyzw( 0,0,0,0 );

            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            this.geodesic.getVertexWeight( coord, v, wgt, idx );
            wgt.toBuf( weights, i*4 );
            idx.toBuf( indices, i*4 );
        }

        return [ weights, indices ];
    }
    //#endregion
}


function SkinWeightMaterial( bIdx=4 ){
    let mat = new THREE.RawShaderMaterial({
        //side        : (isDoubleSide)? THREE.DoubleSide : THREE.FrontSide,
		uniforms		:  {
            boneIdx   : { type :'float', value:bIdx },
        },
        
        vertexShader	: `#version 300 es
        in	vec3	position;
        in  vec4    skinIndex;
        in  vec4    skinWeight;
        
        out vec3 frag_color;

        uniform     float   boneIdx;
        uniform 	mat4	modelMatrix;
        uniform 	mat4	viewMatrix;
        uniform 	mat4	projectionMatrix;

        const vec3 red   = vec3( 1.0, 0.0, 0.0 );
        const vec3 green = vec3( 0.0, 1.0, 0.0 );
        const vec3 blue  = vec3( 0.0, 0.0, 1.0 );

		void main(){
            int bIdx    = int( boneIdx );
            ivec4 sIdx  = ivec4( skinIndex );
            float wgt   = 0.0;

            if( sIdx.x == bIdx )      wgt = skinWeight.x;
            else if( sIdx.y == bIdx ) wgt = skinWeight.y;
            else if( sIdx.z == bIdx ) wgt = skinWeight.z;
            else if( sIdx.w == bIdx ) wgt = skinWeight.w;

            if( wgt > 0.5 ) frag_color = mix( green, red, wgt * 2.0 + 1.0 );
            else            frag_color = mix( blue, green, wgt * 2.0 );

            vec4 wpos   = modelMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * viewMatrix * wpos; 
        }`,
        
		fragmentShader	: `#version 300 es
        precision mediump float;      
        in  vec3 frag_color;
        out	vec4 out_color;

        void main() {
		    out_color = vec4( frag_color, 1.0 );
		}`,
    });

    return mat;
}


</script></bod4></html>