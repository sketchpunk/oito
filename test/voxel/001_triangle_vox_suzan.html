<!DOCTYPE html><html><head><title></title></head><body><script type="module">
    
import Starter, { THREE }  from "../lib/starter.js";
import PointsMesh          from "../lib/PointsMesh.js";
import LinesMesh           from "../lib/LinesMesh.js";

import Vec3                from "../../dist/Vec3.js";
import Quat                from "../../dist/Quat.js";
import Intersect           from "../../dist/geometry/Intersect.js";

import Gltf                from "../../dist/misc/Gltf2.js";

/*
https://github.com/meshonline/Surface-Heat-Diffuse-Skinning
https://github.com/Eisenwave/obj2voxel
https://github.com/mattatz/unity-voxel
https://www.gamedeveloper.com/programming/triangle-mesh-voxelization
https://bronsonzgeb.com/index.php/2021/06/26/volumetric-heat-diffusion-for-automatic-mesh-skinning/
https://github.com/tunabrain/sparse-voxel-octrees
https://www.youtube.com/watch?v=-RpqbC5-Z0E  
http://blog.wolfire.com/2009/11/volumetric-heat-diffusion-skinning/  
http://blog.wolfire.com/2009/11/Triangle-mesh-voxelization 
https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/
https://www.gedge.ca/dev/2014/08/17/greedy-voxel-meshing
*/

let App, pnt, ln, Vol,
    Tri = [
        new Vec3( -1, 0, 0 ),
        new Vec3( 1, 0, 1 ),
        new Vec3( 1, 0, -1 ),
    ];

window.addEventListener( "load", async _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 0, 20, 6, [0,0.1,0] ).render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pnt = new PointsMesh( 100 );
    App.add( pnt.mesh );

    ln = new LinesMesh( 5000 );
    App.add( ln.mesh );
    //ln.box( Grid.minBound, Grid.maxBound, 0x00ff00 );

    let gltf = await Gltf.fetch( './suzanne_hpoly.gltf' );
    let prim = gltf.getMesh().primitives[ 0 ];

    let geo     = new THREE.BufferGeometry();
    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    geo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );
    geo.setAttribute( 'normal',     new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );

    geo.computeBoundingBox();
    let mesh    = new THREE.Mesh( geo, new THREE.MeshPhongMaterial() );

    //console.log( geo );
    App.add( mesh );

    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //createTriangle();
    //const tbox = getMeshBoundingBox();
    //ln.box( tbox.min, tbox.max, 0xb0b0b0 );

    const bmin = new Vec3().fromStruct( geo.boundingBox.min );
    const bmax = new Vec3().fromStruct( geo.boundingBox.max );
    //ln.box( bmin, bmax, 0xb0b0b0 );

    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    console.time();

    Vol = new VoxelVolume();
    Vol.setCellSize( 0.1 );
    Vol.fitBounds( bmin, bmax );

    ln.box( Vol.minBound, Vol.maxBound, 0x00ffff );
    /*
    for( let v of Vol.iterCell() ){
        ln.box( v.min, v.max );
    }
    */


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //let vertices = Vec3.flattenVecArray( Tri );
    //let indices  = [ 0, 1, 2 ];

    Voxelizer.fromMesh( prim.indices.data, prim.position.data, Vol );

    for( const c of Vol.iterCell() ){
        if( c.isOn ) ln.box( c.min, c.max );
    }
    console.timeEnd();
    console.log( 'Tri Count', prim.indices.data.length / 3 );
});

function createTriangle(){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let verts = new Float32Array( Tri.length * 3 );
    let i     = 0;
    let rot   = Quat.fromEuler( 45, 0, -30 );

    for( const v of Tri ){
        v   .transformQuat( rot )
            .toBuf( verts, i );

        pnt.add( v, 0x00ffff, 2 );        
        i += 3;
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Geometry + Skinned Mesh
    let geo     = new THREE.BufferGeometry();
    //geo.setIndex( new THREE.BufferAttribute( tfPrim.indices.data, 1 ) );
    geo.setAttribute( 'position',   new THREE.BufferAttribute( verts, 3 ) );
    //geo.setAttribute( 'normal',     new THREE.BufferAttribute( tfPrim.normal.data, tfPrim.normal.componentLen ) );
    //geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( tfPrim.joints_0.data, tfPrim.joints_0.componentLen ) );
    //geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( tfPrim.weights_0.data, tfPrim.weights_0.componentLen ) );

    let mesh    = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( { color:0x808080, side:THREE.DoubleSide }) );
    App.add( mesh );
}

function getMeshBoundingBox(){
    const min = new Vec3(  1000000 );
    const max = new Vec3( -1000000 );

    for( const v of Tri ){
        min.min( v );
        max.max( v );
    }

    return { min, max };
}


class VoxelVolume{
    constructor(){
        this.minBound   = new Vec3();
        this.maxBound   = new Vec3();
        this.cellLen    = new Vec3();
        this.cellSize   = 0;
        this.cells      = null;
    }

    setCellSize( s ){ this.cellSize = s; return this; }

    setOn( x, y, z ){
        const idx = this.coordIdx( x, y, z );
        this.cells[ idx ] = 1;
        return this;
    }

    fitBounds( vmin, vmax ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Figure out how many voxels can be made in mesh bounding box
        const vsize = Vec3
            .sub( vmax, vmin )          // Get Length of Each Axis
            .divScale( this.cellSize )  // How Many Cells Fit per Axis
            .ceil()                     // OverShoot
            .copyTo( this.cellLen )     // Save Cell Counts
            .scale( this.cellSize );    // Actual Volume Size

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Set the starting volume
        this.minBound.xyz( 0, 0, 0 );
        this.maxBound.copy( vsize );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Move Volume's Mid Point to the Mesh's Mid Point
        const aMid  = Vec3.lerp( vmin, vmax, 0.5 );
        const bMid  = Vec3.lerp( this.minBound, this.maxBound, 0.5 );
        const delta = Vec3.sub( bMid, aMid );

        this.minBound.sub( delta );
        this.maxBound.sub( delta );

        this.buildCellArray();
        return this;
    }

    buildCellArray(){
        const size   = this.cellLen;
        const tCells = size.x * size.z * size.y;
        this.cells   = new Uint8Array( tCells );
    }

    coordIdx( x, y, z ){
        return this.cellLen[ 0 ] * this.cellLen[ 2 ] * y +
               this.cellLen[ 0 ] * z + x;
    }

    idxCoord( i, out ){
        const xzLen = this.cellLen.x * this.cellLen.z;
        const y     = Math.floor( i / xzLen );
        const xz    = i - y * xzLen;
        const z     = Math.floor( xz / this.cellLen.x );        

        out[0] = xz - z * this.cellLen.x;
        out[1] = y;
        out[2] = z;
    }

    posCoord( pos, out ){
        out .fromSub( pos, this.minBound )
            .divScale( this.cellSize )
            .floor()
        ;

        //console.log( pos[0], this.minBound[ 0 ] );

        //console.log( out );
    }

    coordBound( coord, min, max ){
        min .fromScale( coord, this.cellSize )
            .add( this.minBound );
        
        max .fromAdd( coord, [1,1,1] )
            .scale( this.cellSize )
            .add( this.minBound );
    }

    iterCell(){
        let   i      = 0;
        const len    = this.cells.length;
        const val    = {
            min   : new Vec3(),
            max   : new Vec3(),
            coord : new Vec3(),
            isOn  : false,
        };

        const result = { done: false, value: val };
        const next = ()=>{
            if( i >= len ) result.done = true;
            else{
                val.isOn = ( this.cells[ i ] != 0 );

                this.idxCoord( i++, val.coord );

                val.min
                    .fromScale( val.coord, this.cellSize )
                    .add( this.minBound );

                val.max
                    .fromAdd( val.coord, [1,1,1] )
                    .scale( this.cellSize )
                    .add( this.minBound );
            }
            return result;
        };

        return { [Symbol.iterator]() { return { next }; } };
    }
}

class Voxelizer{
    static a   = new Vec3();
    static b   = new Vec3();
    static c   = new Vec3();
    static min = new Vec3();
    static max = new Vec3();

    static minCoord = new Vec3();
    static maxCoord = new Vec3();

    static cellMin  = new Vec3();
    static cellMax  = new Vec3();

    static fromMesh( indices, vertices, voxVol ){
        let i;
        console.log( voxVol );
        for( i=0; i < indices.length; i+=3 ){
            this.processTri(
                indices[ i ],
                indices[ i+1 ],
                indices[ i+2 ],
                vertices,
                voxVol,
            );
        }
    }

    static processTri( ia, ib, ic, vertices, voxVol ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Get the Vertices
        const a    = this.a.fromBuf( vertices, ia * 3 );
        const b    = this.b.fromBuf( vertices, ib * 3 );
        const c    = this.c.fromBuf( vertices, ic * 3 );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute its bounding Box
        const vmin = this.min.copy( a ).min( b ).min( c );
        const vmax = this.max.copy( a ).max( b ).max( c );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute the Voxel Coordinates of the area
        // the triangle takes up with its bounding box.
        voxVol.posCoord( vmin, this.minCoord );
        voxVol.posCoord( vmax, this.maxCoord );

        const [ minx, miny, minz ] = this.minCoord;
        const [ maxx, maxy, maxz ] = this.maxCoord;

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Loop every voxel the triangle might be in and do
        // an intersection test to see if the triangle is truely
        // in the voxel cell.
        
        let x, y, z, isHit;
        let cnt = 0;
        for( y=miny; y <= maxy; y++ ){
            for( z=minz; z <= maxz; z++ ){
                for( x=minx; x <= maxx; x++ ){
                    
                    voxVol.coordBound( [x,y,z], this.cellMin, this.cellMax );
                    isHit = Intersect.triangle_aabb( a, b, c, this.cellMin, this.cellMax );

                    if( isHit ){
                        //ln.box( this.cellMin, this.cellMax );
                        voxVol.setOn( x, y, z );
                        cnt++
                    }
                }
            }
        }
        //console.log( cnt );
    }

}

// Triange / AABB Intersection, Following similar implementation
// https://gist.github.com/yomotsu/d845f21e2e1eb49f647f
// https://github.com/mrdoob/three.js/blob/master/src/math/Box3.js
// https://github.com/mattatz/unity-voxel/blob/master/Assets/Packages/Voxelizer/Scripts/CPUVoxelizer.cs
</script></body></html>