<!DOCTYPE html><html><head><title></title></head><body><script type="module">
    
import Starter, { THREE }  from "../lib/starter.js";
import PointsMesh          from "../lib/PointsMesh.js";
import LinesMesh           from "../lib/LinesMesh.js";

import Vec3                from "../../dist/Vec3.js";
import Quat                from "../../dist/Quat.js";
import Intersect           from "../../dist/geometry/Intersect.js";

import Gltf                from "../../dist/misc/Gltf2.js";

import VoxelChunk          from "../../dist/voxel/VoxelChunk.js";
import Voxelizer           from "../../dist/voxel/Voxelizer.js";
import VoxelMesh           from "../../dist/voxel/VoxelMesh.js";

/*
https://github.com/meshonline/Surface-Heat-Diffuse-Skinning
https://github.com/Eisenwave/obj2voxel
https://github.com/mattatz/unity-voxel
https://www.gamedeveloper.com/programming/triangle-mesh-voxelization
https://bronsonzgeb.com/index.php/2021/06/26/volumetric-heat-diffusion-for-automatic-mesh-skinning/
https://github.com/tunabrain/sparse-voxel-octrees
https://www.youtube.com/watch?v=-RpqbC5-Z0E  
http://blog.wolfire.com/2009/11/volumetric-heat-diffusion-skinning/  
http://blog.wolfire.com/2009/11/Triangle-mesh-voxelization 
https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/
https://www.gedge.ca/dev/2014/08/17/greedy-voxel-meshing
*/

let App, pnt, ln
let gChunk, gVox, gVMesh;

window.addEventListener( "load", async _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 0, 20, 6, [0,0.1,0] ).render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //pnt = new PointsMesh( 100 );
    //App.add( pnt.mesh );

    ln = new LinesMesh( 5000 );
    App.add( ln.mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let gltf = await Gltf.fetch( './suzanne_hpoly.gltf' );
    let prim = gltf.getMesh().primitives[ 0 ];

    let ggeo     = new THREE.BufferGeometry();
    ggeo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    ggeo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );
    ggeo.setAttribute( 'normal',     new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );

    ggeo.computeBoundingBox();
    let mesh    = new THREE.Mesh( ggeo, new THREE.MeshPhongMaterial() );
    
    mesh.position.x = 1.5;
    App.add( mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    gVox   = new Voxelizer();
    gChunk = new VoxelChunk( 0.1 );
    gChunk.fitBound( ggeo.boundingBox.min.toArray(), ggeo.boundingBox.max.toArray() );

    ln.box( gChunk.minBound, gChunk.maxBound, 0x00ffff );


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    gVox.fromGeometry( gChunk, prim.position.data, prim.indices.data );

    const geo = { vertices:[], normals:[], indices :[], texcoord:[] };
    VoxelMesh.fromChunk( gChunk, geo );

    let bgeo     = new THREE.BufferGeometry();
    bgeo.setIndex( new THREE.BufferAttribute( new Uint32Array( geo.indices ), 1 ) );
    bgeo.setAttribute( 'position',   new THREE.BufferAttribute( new Float32Array(geo.vertices), 3 ) );
    bgeo.setAttribute( 'normal',     new THREE.BufferAttribute( new Float32Array(geo.normals), 3 ) );

    let meshx    = new THREE.Mesh( bgeo, new THREE.MeshPhongMaterial( {color:0xff0000 }) );
    App.add( meshx );

});


function getMeshBoundingBox(){
    const min = new Vec3(  1000000 );
    const max = new Vec3( -1000000 );

    for( const v of Tri ){
        min.min( v );
        max.max( v );
    }

    return { min, max };
}


// Triange / AABB Intersection, Following similar implementation
// https://gist.github.com/yomotsu/d845f21e2e1eb49f647f
// https://github.com/mrdoob/three.js/blob/master/src/math/Box3.js
// https://github.com/mattatz/unity-voxel/blob/master/Assets/Packages/Voxelizer/Scripts/CPUVoxelizer.cs
</script></body></html>