<!DOCTYPE html><html><head><title></title></head><body><script type="module">

import Starter, { THREE }   from "../lib/starter.js";
import PointsMesh           from "../lib/PointsMesh.js";
import LinesMesh            from "../lib/LinesMesh.js";

import Mat4                 from "../../dist/Mat4.js";
import Vec3                 from "../../dist/Vec3.js";
import Ray                  from "../../dist/ray/Ray.js";

import { BoundingBox, AABBRay, RayBBoxResult } from "../../dist/ray/BoundingBox.js";

let App;
let ln, pnt;
let Data = {
    min : [ 0,0,0 ],
    max : [ 1,1,1 ],
    box : null,
};

window.addEventListener( "load", _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:false, grid:true } );
    App.set_camera( 0, 20, 6 ).render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pnt = new PointsMesh( 50 );
    App.add( pnt.mesh );

    ln = new LinesMesh( 50 );
    App.add( ln.mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //pnt.add( Data.pos, 0x00ff00, 3 );
    //ln.add( Data.pos, Vec3.scale( Data.norm, 0.5 ).add( Data.pos ), 0x00ff00 );
    Data.box = new BoundingBox( Data.min, Data.max );
    ln.box( Data.min, Data.max, 0x909090 );
});

window.addEventListener( "pointerdown", e=>{
    if( e.button != 2 ) return;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Grab Info that needed to Project the Mouse Position into the 3D Scene
    const proj  = new Mat4();
    const world = new Mat4();
    const size  = new THREE.Vector2();
    const x     = e.clientX;
    const y     = e.clientY;

    App.renderer.getSize( size );                   // Need Size of Canvas
    App.camera.projectionMatrix.toArray( proj );    // Need Projection Matrix
    App.camera.matrixWorld.toArray( world );        // World Space Transform of Camera

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute the Ray and visually draw a line
    const ray = new Ray();
    ray.fromScreenProjection( x, y, size.x, size.y, proj, world );
    ln.add( ray.origin, ray.end, 0x00ffff );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let t;
    const rayBox    = new AABBRay( ray );
    const results   = new RayBBoxResult();
    
    if( Data.box.rayIntersects( ray, rayBox, results ) ){
        const v = new Vec3();
        const d = new Vec3();

        //---------------------------
        // Entry
        ray.posAt( results.tMin, v );
        results.getEntryNorm( d, 0.2 ).add( v );

        pnt.add( v, 0x00ff00, 3 );
        ln.add( v, d, 0x00ff00 );

        //---------------------------
        // Exit
        ray.posAt( results.tMax, v );
        results.getExitNorm( d, 0.2 ).add( v );
        
        pnt.add( v, 0xff0000, 3 );
        ln.add( v, d, 0xff0000 );
    }
} );



</script></body></html>