<!DOCTYPE html><html><head><title></title></head><body><script type="module">
//#region IMPORTS    
import Starter, { THREE }   from '../_lib/threejs/Starter.js';
//import PointsMesh           from '../_lib/threejs/PointsMesh.js';
import Gltf2Util            from '../_lib/threejs/Gltf2Util.js';

import { Armature, SkinMTX }    from '../../dist/armature.js';
import Gltf2                            from '../../dist/parsers/Gltf2.js';
import { Clip, Animator, Retarget }     from '../../dist/animator.js';
import Util                 from './lib/Util.js';
//#endregion

//#region MAIN
let App;
let Ref = {};

function onRender( dt=0, et=0 ){
    Ref.shader.uniforms.time.value = et;
}

window.addEventListener( "load", async _=>{
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 0, 20, 4, [0,0.8,0] );
    App.onRender = onRender;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup Retargeting
    Ref.retarget = new Retarget();
    Ref.retarget.anim.inPlace = true;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Load Source & Target - Each will update Retarget with their info
    const [ glSrc, glTar, tex ] = await Promise.all([
        Gltf2.fetch( '../_res/anim/Walking.gltf' ),
        Gltf2.fetch( '../_res/models/tina/tina.gltf' ),
    ]);

    setup_source( glSrc );
    setup_target( glTar );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Final Setups
    Ref.retarget.bind();                    // Bind the Two Skeletons Together
    
    const texClip = createTextureData();    // Run Retargeting while saving each frame into a texture

    // Create Custom Shader & Set Animation Information
    Ref.shader = SkinMTXMaterial_DataTex( 'cyan', texClip );
    Ref.shader.uniforms.frameCount.value    = Ref.retarget.anim.clip.frameCount;
    Ref.shader.uniforms.duration.value      = Ref.retarget.anim.clip.duration;

    // Apply Shader to Mesh
    Ref.tarMesh.material                    = Ref.shader;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.render();
});

function armature_from_gltf( gltf, defaultBoneLen = 0.07 ){
    const arm  = new Armature();
    const skin = gltf.getSkin();

    for( let j of skin.joints ){
        arm.addBone( j.name, j.parentIndex, j.rotation, j.position, j.scale );
    }

    // Create Bind Pose
    arm.bind( SkinMTX, defaultBoneLen );

    // Armature has a Transform on itself sometimes
    // Apply it at the Offset Transform gets preapplied to the root
    arm.offset.set( skin.rotation, skin.position, skin.scale );

    return arm;
}

function setup_source( gltf ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const arm       = armature_from_gltf( gltf );   // Get Animation Skeleton
    const anim      = gltf.getAnimation();          // Get Animation
    const clip      = Clip.fromGLTF2( anim );       // ... Convert to Clip

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.retarget
        .setClipArmature( arm )
        .setClip( clip );
}

function setup_target( gltf, tex ){
    const arm = armature_from_gltf( gltf );   // Get Target Skeleton
    Ref.tarArm = arm;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.retarget
        .setTargetArmature( arm )
        .getTargetPose().fromGLTF2( gltf.getPose() );   // Resting Pose is A, but requires T for retargeting
                                                        // So pull TPose from file & apply it as the starting pose for retargeting

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    const [ inst_pos, inst_dat ] = randomInstances( 50 );

    const prim = gltf.getMesh().primitives[ 0 ];
    const geo  = new THREE.InstancedBufferGeometry();
    
    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    geo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );
    geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
    geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data, prim.joints_0.componentLen ) );
    geo.setAttribute( "i_pos",      new THREE.InstancedBufferAttribute( inst_pos, 3 ) );
    geo.setAttribute( "i_dat",      new THREE.InstancedBufferAttribute( inst_dat, 2 ) );
    geo.instanceCount       = inst_pos.length / 3;
    geo._maxInstanceCount   = Infinity; //ThreeJS is buggy, found in a forum setting this can fix Instancing not rendering sometimes

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.tarMesh = new THREE.Mesh( geo, null );
    App.add( Ref.tarMesh );
}

function createTextureData(){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Each Pixel Row Contains all the Keyframe Offset Matrices of 1 Bone.
    // Each 4 Pixels on a row is a single offset matrix.
    
    const frameCnt = Ref.retarget.anim.clip.frameCount;
    const texInfo  = Ref.tarArm.skin.getTextureInfo( frameCnt );
    const buf      = new Float32Array( texInfo.bufferFloatSize );

    const tarPose  = Ref.retarget.getTargetPose();
    const offsets  = Ref.tarArm.getSkinOffsets()[0];

    let f, bIdx, colIdx, offIdx, rowIdx, startIdx;

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for( f=0; f < frameCnt; f++ ){
        Ref.retarget.atKey( f ).applyRetarget();    // Retarget Animation Frame
        Ref.tarArm.updateSkinFromPose( tarPose );  // Generate Skinning Offsets
        colIdx = f * texInfo.strideFloatLength;     // Starting Float Index of the column

        // Loop Each Bone in the Animated Pose
        for( bIdx=0; bIdx < texInfo.boneCount; bIdx++ ){
            offIdx      = bIdx * texInfo.strideFloatLength; // Index of Bone's Offset Matrix
            rowIdx      = bIdx * texInfo.floatRowSize;      // Row Index for the Bone in the Texture  
            startIdx    = rowIdx + colIdx;                  // Starting Index to start coping Data.

            // Loop each float in the bone's offset matrix
            // Copy it into the correct stop in the texture buffer.
            for( let k=0; k < texInfo.strideFloatLength; k++ ){
                buf[ startIdx + k ] = offsets[ offIdx + k ];
            }
        }
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const texData = new THREE.DataTexture( 
        buf, 
        texInfo.pixelWidth, 
        texInfo.pixelHeight, 
        THREE.RGBAFormat,
        THREE.FloatType,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping, 
        THREE.ClampToEdgeWrapping, 
        THREE.NearestFilter, 
        THREE.NearestFilter, 
    );

    return texData;
}

function randomInstances( cnt ){
    const pos = new Float32Array( cnt * 3 );
    const dat = new Float32Array( cnt * 2 );

    let ra, rb, rc;
    let xMin = -10;
    let xMax = 10;

    for( let i=0; i < cnt; i++ ){
        let iii = i * 3;
        let ii =  i * 2;
        ra = Math.random();
        rb = Math.random();
        rc = Math.random();
        
        pos[ iii+0 ] = xMin * (1-ra) + xMax * ra;
        pos[ iii+1 ] = 0
        pos[ iii+2 ] = xMin * (1-rb) + xMax * rb;

        dat[ ii+0 ]  = Math.PI * 2 * rc;
        dat[ ii+1 ]  = 1.2 * ra;
    }

    return [ pos, dat ];
}

//#endregion


//#region CUSTOM MATRIX SKINNING SHADER THAT USES DATA TEXTURES FOR GPU ANIMATING

function SkinMTXMaterial_DataTex( val='cyan', dTex ){
    const isTex    = ( val instanceof THREE.Texture );
    const uniforms = {
        clip        : { type :'sampler2D', value:dTex },
        frameCount  : { type :'float', value:0 },
        duration    : { type :'float', value:0 },
        time        : { type :'float', value:0 },
    };

    if( !isTex ) uniforms.color     = { type :'vec3', value:new THREE.Color( val ) };
    else         uniforms.texBase   = { type :'sampler2D', value:val };

    const matConfig = {
        side            : THREE.DoubleSide,
        uniforms        : uniforms,
        vertexShader    : VERT_SRC,
        fragmentShader	: ( !isTex )? FRAG_COL : FRAG_TEX,
    }

    const mat       = new THREE.RawShaderMaterial( matConfig );
    mat.extensions  = { derivatives : true }; // If not using WebGL2.0 and Want to use dfdx or fwidth, Need to load extension
    return mat;
}

// HANDLE SKINNING
const VERT_SRC = `#version 300 es
in vec3 position;   // Vertex Position
in vec3 normal;     // Vertex Normal
in vec2 uv;         // Vertex Texcoord
in vec4 skinWeight; // Bone Weights
in vec4 skinIndex;  // Bone Indices
in vec3 i_pos;      // Instance Position.
in vec2 i_dat;      // Instance : x - Rotation Angle, y-Animation Offset

uniform float     frameCount;
uniform float     duration;
uniform float     time;
uniform sampler2D clip;

uniform mat4 modelMatrix;       // Matrices should be filled in by THREE.JS Automatically.
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

out vec3 frag_wpos;             // Fragment World Space Position
out vec3 frag_norm;             // Fragment Normal
out vec2 frag_uv;               // Fragment Texcoord

////////////////////////////////////////////////////////////////////////

/*
Texture Setup
- Every Row is a Bone, Can use Bone Index as the X coord.
- Every 4 Pixels is 1 Offset Matrix
*/

// Pull out Matrix from Texture : 4 Pixel Fetches starting at specific x and y coord
mat4x4 texMat4( sampler2D tex, int x, int y ){
    return mat4x4( 
        texelFetch( tex, ivec2( x, y ), 0 ),
        texelFetch( tex, ivec2( x+1, y ), 0 ),
        texelFetch( tex, ivec2( x+2, y ), 0 ),
        texelFetch( tex, ivec2( x+3, y ), 0 )
    );
}

mat4 getBoneMatrix( sampler2D tex, vec4 idx, vec4 wgt, int x ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NORMALIZE BONE WEIGHT VECTOR - INCASE MODEL WASN'T PREPARED LIKE THAT
    // If Weights are not normalized, Merging the Bone Offsets will create artifacts
    int a = int( idx.x ),
        b = int( idx.y ),
        c = int( idx.z ),
        d = int( idx.w );
    
    wgt *= 1.0 / ( wgt.x + wgt.y + wgt.z + wgt.w );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // MERGE THE BONE OFFSETS BASED ON WEIGHT
    mat4 bone_wgt =
        texMat4( tex, x, a ) * wgt.x +  
        texMat4( tex, x, b ) * wgt.y +
        texMat4( tex, x, c ) * wgt.z +
        texMat4( tex, x, d ) * wgt.w;

    return bone_wgt;
}

////////////////////////////////////////////////////////////////////////

vec3 yRot( vec3 p, float rad ){
    float c = cos( rad );
    float s = sin( rad );
    return vec3(
        p.x * c - p.z * s,
        p.y,
        p.x * s + p.z * c
    );
}

void main() {
    float animTime  = mod( time + i_dat.y, duration );        // Truncate Global Time between 0 and total seconds
    float ntime     = animTime / duration;                    // Normalize Time
    float frame     = frameCount * ntime;                     // Figure out which frame ( or between 2 frames)
    int pixel_x     = int( floor( frame ) ) * 4;              // Floor to get starting frame, mul by 4 pixels per Mat4 for texture x coord

    mat4 boneMatrix = getBoneMatrix( clip, skinIndex, skinWeight, pixel_x );    // Get the Skinning Matrix
    mat4 mbMatrix   = modelMatrix * boneMatrix;                                 // Merge Model and Bone Matrices together

    vec4 wpos       = mbMatrix * vec4( position, 1.0 );                         // Use new Matrix to Transform Vertices
    wpos.xyz        = yRot( wpos.xyz, i_dat.x ) + i_pos;                        // Apply Instance Pos / Rotation

    frag_wpos       = wpos.xyz;                                                 // Save WorldSpace Position for Fragment Shader
    frag_norm       = mat3( transpose( inverse( mbMatrix ) ) ) * normal;        // Transform Normals using bone + model matrix
    frag_uv         = uv;

    gl_Position     = projectionMatrix * viewMatrix * wpos;
}`;

// FRAGMENT THAT HANDLES BASE COLOR & LIGHTING
const FRAG_COL = `#version 300 es
precision mediump float;

////////////////////////////////////////////////////////////////////////

out     vec4 out_color;
in      vec3 frag_wpos;
in      vec3 frag_norm;

uniform vec3 color;

////////////////////////////////////////////////////////////////////////

#define LITCNT 2
const vec3[] light_pos = vec3[](
    vec3( 0.0, 2.5, 1.0 ),
    vec3( -1.0, 0.0, 1.0 )
);

float computePointLights( vec3[LITCNT] lights, vec3 norm ){
    vec3 light_vec;
    vec3 light_dir;

    float dist;
    float attenuation;
    float diffuse     = 0.0;
    float constant    = 0.5;
    float linear      = 0.5;
    float quadratic   = 0.5;
    
    for( int i=0; i < LITCNT; i++ ){
        light_vec       = lights[i].xyz - frag_wpos;
        light_dir       = normalize( light_vec );
        dist            = length( light_vec );
        attenuation     = 1.0 / ( constant + linear * dist + quadratic * (dist * dist) );
        diffuse        += max( dot( norm, light_dir ), 0.0 ) * attenuation;
    }

    return diffuse;
}

void main(){
    vec3 norm     = normalize( cross( dFdx(frag_wpos), dFdy(frag_wpos) ) ); // Low Poly Normals
    //vec3 norm     = normalize( frag_norm ); // Model's Normals            
    float diffuse = computePointLights( light_pos, norm );
    out_color     = vec4( color * diffuse, 1.0 );

    //out_color.rgb = vec3( 1.0, 0.0, 0.0 );
}`;

//#endregion

</script></body></html>