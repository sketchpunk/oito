<!DOCTYPE html><html><head><title></title></head><body><script type="module">
//#region IMPORTS    
import Starter, { THREE }   from '../_lib/threejs/Starter.js';
//import PointsMesh           from '../_lib/threejs/PointsMesh.js';
import Gltf2Util            from '../_lib/threejs/Gltf2Util.js';

import { Armature, SkinMTX, SkinDQ }    from '../../dist/armature.js';
import Gltf2                            from '../../dist/parsers/Gltf2.js';
import { Clip, Animator, Retarget }     from '../../dist/animator.js';
import Util                 from './lib/Util.js';
//#endregion

let App;
let gExample;
let pnt;
let gMesh;

function onRender( dt=0, et=0 ){
    if( gMesh ){
        gMesh.material.uniforms.time.value = et;
    }
}

window.addEventListener( "load", async _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:true, grid:true } );
    App.set_camera( 0, 20, 4, [0,0.8,0] );
    App.onRender = onRender;

    //pnt = new PointsMesh( 100 );
    //App.add( pnt.mesh );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    gExample = new Example()
    await Promise.all([
        gExample.fetchSource( '../_res/anim/Walking.gltf' ),
        gExample.fetchTarget( '../_res/models/tina/tina.gltf' ),
    ]).then(()=>{
        gExample.bind();    // Do Retargeting Binding
        gExample.build();   // Build Data Texture
    });

    App.render();
});

class Example{
    constructor(){
        this.isReady  = false;
        this.retarget = new Retarget();
        this.retarget.anim.inPlace = true;

        this.srcArm   = null;   // Clip Skeleton
        this.tarArm   = null;   // Target Skeleton
        this.clip     = null;   // Animation Clip
        this.tarTPose = null;   // TPose for Target Sekeleton

        this.tarMesh  = null;   // Final Skinned Mesh 4 Animating
    }

    //#region INITIALIZATION

    async fetchSource( url ){
        const gltf = await Gltf2.fetch( url );
        if( !gltf ){ console.log( 'Error loading GLTF' ); return; }

        this.clip   = Util.clipFromGltf( gltf )
        this.srcArm = Util.armFromGltf( gltf );
    }

    async fetchTarget( url ){
        const gltf = await Gltf2.fetch( url );
        if( !gltf ){ console.log( 'Error loading GLTF' ); return; }

        this.tarArm     = Util.armFromGltf( gltf );
        this.tarTPose   = this.tarArm.newPose().fromGLTF2( gltf.getPose() ).updateWorld( true );
        

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const [ inst_pos, inst_dat ] = this.randomInstances( 20 );
        const prim = gltf.getMesh().primitives[ 0 ];
        const geo  = new THREE.InstancedBufferGeometry();
        geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
        geo.setAttribute( 'position',   new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );
        geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
        geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data, prim.joints_0.componentLen ) );
        geo.setAttribute( "i_pos",      new THREE.InstancedBufferAttribute( inst_pos, 3 ) );
        geo.setAttribute( "i_dat",      new THREE.InstancedBufferAttribute( inst_dat, 2 ) );
        geo.instanceCount       = inst_pos.length / 3;
        geo._maxInstanceCount   = Infinity; //ThreeJS is buggy, found in a forum setting this can fix Instancing not rendering sometimes

        this.tarMesh = new THREE.Mesh( geo, null ); //

    }

    bind(){
        this.retarget
            .setClipArmature( this.srcArm )
            .setClip( this.clip )
            .setTargetArmature( this.tarArm )
            .getTargetPose().copy( this.tarTPose )
        ;

        this.retarget.bind();
        this.isReady = true;
    }

    //#endregion

    randomInstances( cnt ){
        const pos = new Float32Array( cnt * 3 );
        const dat = new Float32Array( cnt * 2 );

        let ra, rb, rc;
        let xMin = -10;
        let xMax = 10;

        for( let i=0; i < cnt; i++ ){
            let iii = i * 3;
            let ii =  i * 2;
            ra = Math.random();
            rb = Math.random();
            rc = Math.random();
            
            pos[ iii+0 ] = xMin * (1-ra) + xMax * ra;
            pos[ iii+1 ] = 0
            pos[ iii+2 ] = xMin * (1-rb) + xMax * rb;

            dat[ ii+0 ]  = Math.PI * 2 * rc;
            dat[ ii+1 ]  = 1.2 * ra;
        }

        return [ pos, dat ];
    }

    build(){
        if( !this.isReady ) return;

        const dTex = this.createTextureData();
        const mat  = SkinMTXMaterial_DataTex( 'cyan', dTex );
        mat.uniforms.frameCount.value    = this.clip.frameCount;
        mat.uniforms.duration.value      = this.clip.duration;

        this.tarMesh.material = mat;
        App.add( this.tarMesh );
        gMesh = this.tarMesh;
    } 

    createTextureData(){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Each Pixel Row Contains all the Keyframe Offset Matrices of 1 Bone.
        // Each 4 Pixels on a row is a single offset matrix.
        
        const frameCnt = this.clip.frameCount;
        const texInfo  = this.tarArm.skin.getTextureInfo( frameCnt );
        const buf      = new Float32Array( texInfo.bufferFloatSize );

        const tarPose  = this.retarget.getTargetPose();
        const offsets  = this.tarArm.getSkinOffsets()[0];

        let f, bIdx, colIdx, offIdx, rowIdx, startIdx;

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for( f=0; f < frameCnt; f++ ){
            this.retarget.atKey( f).applyRetarget();    // Retarget Animation Frame
            this.tarArm.updateSkinFromPose( tarPose );  // Generate Skinning Offsets
            colIdx = f * texInfo.strideFloatLength;     // Starting Float Index of the column

            // Loop Each Bone in the Animated Pose
            for( bIdx=0; bIdx < texInfo.boneCount; bIdx++ ){
                offIdx      = bIdx * texInfo.strideFloatLength; // Index of Bone's Offset Matrix
                rowIdx      = bIdx * texInfo.floatRowSize;      // Row Index for the Bone in the Texture  
                startIdx    = rowIdx + colIdx;                  // Starting Index to start coping Data.

                // Loop each float in the bone's offset matrix
                // Copy it into the correct stop in the texture buffer.
                for( let k=0; k < texInfo.strideFloatLength; k++ ){
                    buf[ startIdx + k ] = offsets[ offIdx + k ];
                }
            }
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const texData = new THREE.DataTexture( 
            buf, 
            texInfo.pixelWidth, 
            texInfo.pixelHeight, 
            THREE.RGBAFormat,
            THREE.FloatType,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping, 
            THREE.ClampToEdgeWrapping, 
            THREE.NearestFilter, 
            THREE.NearestFilter, 
        );

        return texData;
    }
}


function SkinMTXMaterial_DataTex( val='cyan', dTex ){
    const isTex    = ( val instanceof THREE.Texture );
    const uniforms = {
        clip        : { type :'sampler2D', value:dTex },
        frameCount  : { type :'float', value:0 },
        duration    : { type :'float', value:0 },
        time        : { type :'float', value:0 },
    };

    if( !isTex ) uniforms.color     = { type :'vec3', value:new THREE.Color( val ) };
    else         uniforms.texBase   = { type :'sampler2D', value:val };

    const matConfig = {
        side            : THREE.DoubleSide,
        uniforms        : uniforms,
        vertexShader    : VERT_SRC,
        fragmentShader	: ( !isTex )? FRAG_COL : FRAG_TEX,
    }

    const mat       = new THREE.RawShaderMaterial( matConfig );
    mat.extensions  = { derivatives : true }; // If not using WebGL2.0 and Want to use dfdx or fwidth, Need to load extension
    return mat;
}

//#region SHADER CODE

// HANDLE SKINNING
const VERT_SRC = `#version 300 es
in vec3 position;   // Vertex Position
in vec3 normal;     // Vertex Normal
in vec2 uv;         // Vertex Texcoord
in vec4 skinWeight; // Bone Weights
in vec4 skinIndex;  // Bone Indices
in vec3 i_pos;      // Instance Position.
in vec2 i_dat;      // Instance : x - Rotation Angle, y-Animation Offset

uniform float     frameCount;
uniform float     duration;
uniform float     time;
uniform sampler2D clip;

uniform mat4 modelMatrix;       // Matrices should be filled in by THREE.JS Automatically.
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

out vec3 frag_wpos;             // Fragment World Space Position
out vec3 frag_norm;             // Fragment Normal
out vec2 frag_uv;               // Fragment Texcoord

////////////////////////////////////////////////////////////////////////

/*
Texture Setup
- Every Row is a Bone, Can use Bone Index as the X coord.
- Every 4 Pixels is 1 Offset Matrix
*/

// Pull out Matrix from Texture : 4 Pixel Fetches starting at specific x and y coord
mat4x4 texMat4( sampler2D tex, int x, int y ){
    return mat4x4( 
        texelFetch( tex, ivec2( x, y ), 0 ),
        texelFetch( tex, ivec2( x+1, y ), 0 ),
        texelFetch( tex, ivec2( x+2, y ), 0 ),
        texelFetch( tex, ivec2( x+3, y ), 0 )
    );
}

mat4 getBoneMatrix( sampler2D tex, vec4 idx, vec4 wgt, int x ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NORMALIZE BONE WEIGHT VECTOR - INCASE MODEL WASN'T PREPARED LIKE THAT
    // If Weights are not normalized, Merging the Bone Offsets will create artifacts
    int a = int( idx.x ),
        b = int( idx.y ),
        c = int( idx.z ),
        d = int( idx.w );
    
    wgt *= 1.0 / ( wgt.x + wgt.y + wgt.z + wgt.w );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // MERGE THE BONE OFFSETS BASED ON WEIGHT
    mat4 bone_wgt =
        texMat4( tex, x, a ) * wgt.x +  
        texMat4( tex, x, b ) * wgt.y +
        texMat4( tex, x, c ) * wgt.z +
        texMat4( tex, x, d ) * wgt.w;

    return bone_wgt;
}

////////////////////////////////////////////////////////////////////////

vec3 yRot( vec3 p, float rad ){
    float c = cos( rad );
    float s = sin( rad );
    return vec3(
        p.x * c - p.z * s,
        p.y,
        p.x * s + p.z * c
    );
}

void main() {
    /**/
    float animTime  = mod( time + i_dat.y, duration );        // Truncate Global Time between 0 and total seconds
	float ntime		= animTime / duration;          // Normalize Time
	float frame		= frameCount * ntime;           // Figure out which frame ( or between 2 frames)
	int pixel_x		= int( floor( frame ) ) * 4;    // Floor to get starting frame, mul by 4 pixels per Mat4 for texture x coord

    mat4 boneMatrix = getBoneMatrix( clip, skinIndex, skinWeight, pixel_x );      // Get the Skinning Matrix
    mat4 mbMatrix   = modelMatrix * boneMatrix;                             // Merge Model and Bone Matrices together
    
    vec4 wpos       = mbMatrix * vec4( position, 1.0 );                     // Use new Matrix to Transform Vertices
    wpos.xyz        = yRot( wpos.xyz, i_dat.x ) + i_pos;                    // Apply Instance Pos / Rotation

    frag_wpos       = wpos.xyz;                                             // Save WorldSpace Position for Fragment Shader
    frag_norm       = mat3( transpose( inverse( mbMatrix ) ) ) * normal;    // Transform Normals using bone + model matrix
    frag_uv         = uv;

    gl_Position     = projectionMatrix * viewMatrix * wpos;
}`;

// FRAGMENT THAT HANDLES BASE COLOR & LIGHTING
const FRAG_COL = `#version 300 es
precision mediump float;

////////////////////////////////////////////////////////////////////////

out     vec4 out_color;
in      vec3 frag_wpos;
in      vec3 frag_norm;

uniform vec3 color;

////////////////////////////////////////////////////////////////////////

#define LITCNT 2
const vec3[] light_pos = vec3[](
    vec3( 0.0, 2.5, 1.0 ),
    vec3( -1.0, 0.0, 1.0 )
);

float computePointLights( vec3[LITCNT] lights, vec3 norm ){
    vec3 light_vec;
    vec3 light_dir;

    float dist;
    float attenuation;
    float diffuse     = 0.0;
    float constant    = 0.5;
    float linear      = 0.5;
    float quadratic   = 0.5;
    
    for( int i=0; i < LITCNT; i++ ){
        light_vec       = lights[i].xyz - frag_wpos;
        light_dir       = normalize( light_vec );
        dist            = length( light_vec );
        attenuation     = 1.0 / ( constant + linear * dist + quadratic * (dist * dist) );
        diffuse        += max( dot( norm, light_dir ), 0.0 ) * attenuation;
    }

    return diffuse;
}

void main(){
    vec3 norm     = normalize( cross( dFdx(frag_wpos), dFdy(frag_wpos) ) ); // Low Poly Normals
    //vec3 norm     = normalize( frag_norm ); // Model's Normals            
    float diffuse = computePointLights( light_pos, norm );
    out_color     = vec4( color * diffuse, 1.0 );

    //out_color.rgb = vec3( 1.0, 0.0, 0.0 );
}`;

// FRAGMENT THAT ONLY RENDERS TEXTURE
const FRAG_TEX = `#version 300 es
precision mediump float;

////////////////////////////////////////////////////////////////////////

out     vec4 out_color;
in      vec2 frag_uv;

uniform sampler2D texBase;

////////////////////////////////////////////////////////////////////////

void main(){
    out_color = texture( texBase, frag_uv );
}`;

//#endregion

</script></body></html>